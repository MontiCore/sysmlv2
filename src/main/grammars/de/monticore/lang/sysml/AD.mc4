/* (c) https://github.com/MontiCore/monticore */
package de.monticore.lang.sysml;


component grammar AD extends de.monticore.lang.sysml.basics.SysMLCommon {

  /* ACTIVITIES */

  ActivityUnit implements Unit = UnitPrefix Activity;
  Activity implements PackagedDefinitionMember = ActivityDeclaration ActivityBody;
  ActivityDeclaration = ["abstract"]? "activity" name:SysMLName ParameterList? SuperclassingList?;
  ParameterList = "(" (ParameterMember || "," )+ ")";
  ActivityBody = ";" | ("{" ActivityBodyItem* "}"); /*
  // Note: Using a syntactic predicate here seems to avoid a possible infinite loop
  		// while incrementally parsing.
  	  | '{' => ActivityBodyItem* '}'
  	  TODO check if this  "=>" is also necessary here. */

  // interface ActivityBodyItem; TODO make item interface ? does not need to necessarily
  ActivityBodyItem =
    NestedDefinitionMember+
    | StructureUsageMember+
    | InitialNodeMember+ (TargetSuccessionMember )*
    | EmptySuccessionMember* ActivityNodeMember+ TargetSuccessionMember*
    | GuardedSuccessionMember+
    | ImportUnit+;


  /* ACTIVITIY MEMBERSHIPS */

  ParameterMember = direction:FeatureDirection? memberName:SysMLName Parameter;
  InitialNodeMember = DefinitionMemberPrefix "first" memberFeature:QualifiedName ";";
  ActivityNodeMember = DefinitionMemberPrefix ActivityNode;
  TargetSuccessionMember = DefinitionMemberPrefix
    ( TargetSuccession | GuardedTargetSuccession | DefaultTargetSuccession);
  GuardedSuccessionMember = GuardedSuccession ";";


  /* STATE DEFINITIONS */

  StateDefinitionUnit implements Unit = UnitPrefix StateDefinition;
  StateDefinition implements PackagedDefinitionMember = StateDefDeclaration StateBody;
  StateDefDeclaration = ["abstract"]? "state" "def" name:SysMLName ParameterList? SuperclassingList?;
  StateBody = ";" | "{" StateBodyPart "}";
  StateBodyPart = (EntryActionMember (EntryTransitionMember)*)? DoActionMember? ExitActionMember? StateBodyItem*;
  // Note: Using a syntactic predicate here seems to avoid a possible infinite loop
  // while incrementally parsing. TODO check necessary => StateBodyItem*
  StateBodyItem = NestedDefinitionMember
    | StructureUsageMember
    | StateMember+ (TargetTransitionSuccessionMember )*
    | TransitionStepMember
    | ImportUnit;
  StateActionUsage = (EmptyActionUsage? ";") | PerformedActionUsage ActivityBody;
  PerformedActionUsage = PerformActionUsageDeclaration | AcceptActionNodeDeclaration | SendActionNodeDeclaration;
  EmptyActionUsage = EmptyNT; //TODO 	{SysML::ActionUsage}

  /* STATE MEMBERSHIPS */

  EntryActionMember = DefinitionMemberPrefix kind:EntryActionKind StateActionUsage;
  EntryActionKind = "entry";
  DoActionMember = DefinitionMemberPrefix kind:DoActionKind StateActionUsage;
  DoActionKind = "do";
  ExitActionMember = DefinitionMemberPrefix kind:ExitActionKind StateActionUsage;
  ExitActionKind = "exit";

  StateMember = DefinitionMemberPrefix ["abstract"]? ("ref" "state" | isComposite:["state"]) StateUsage;
  EntryTransitionMember = DefinitionMemberPrefix (GuardedTargetSuccession | "then" TransitionSuccession ) ";";

  TargetTransitionSuccessionMember =  DefinitionMemberPrefix TargetTransitionStep ";";
  TransitionStepMember = DefinitionMemberPrefix TransitionStep ";";


  //TODO where does Action belong????
  /* ACTIONS */
  ActionUnit implements Unit = UnitPrefix ActionDeclaration ActivityBody;
  ActionDeclaration = ["abstract"]? "action" name:SysMLName TypePart? ActionParameterList? SubsettingPart ValuePart?;
  ActionUsageStd implements ActionUsage = ActionUsageDeclaration ActivityBody;
  ActionUsageDeclaration = (name:SysMLName TypePart? ActionParameterList? SubsettingPart ValuePart?)
    | (TypePart? ActionParameterList? ValuePart?)
    | (RedefinesKeyword Redefinition+ TypePart ActionParameterList? ValuePart?);

  ActionParameterList = "(" ( ActionParameterMemberAndFlowMember || ",")* ")";
  ActionParameterMemberAndFlowMember = ActionParameterMember ActionParameterFlowMember?;
  ActionParameter = ParameterTypePart? ValuePart?;
  ActionParameterFlow =
    ("stream" | "flow") EmptyItemFeatureMember "from" ItemFlowEndMember; //TODO  0xA0129 rule actionParameterFlow contains a closure with at least one alternative that can match an empty string

  PerformActionUsage = PerformActionUsageDeclaration ActivityBody;
  PerformActionUsageDeclaration = ((( name:SysMLName TypePart? "as" )? Subset+)
    |( "action" (name:SysMLName)? TypePart?)) ActionParameterList? SubsettingPart ValuePart?;

  /* ACTIVITY NODES */
  ActivityNode = ActionNode | ControlNode;
  ActionNode = ActionNodeDeclaration ActivityBody;
  ActionNodeDeclaration =   ActionUsageNodeDeclaration
  	| PerformActionNodeDeclaration
  	| AcceptActionNodeDeclaration
  	| SendActionNodeDeclaration;
  ActionUsageNodeDeclaration = ["abstract"]? (("ref" "action") | isComposite:["action"]) ActionUsageDeclaration;
  PerformActionNodeDeclaration = isComposite:"perform" (name:SysMLName TypePart? "as")? Subset+  ActionParameterList?
    SubsettingPart ValuePart?;
  AcceptActionNodeDeclaration = EmptyParameterMember? "accept" (name:SysMLName TypePart?)? "(" ItemFeatureMember+ ")";
  SendActionNodeDeclaration = EmptyParameterMember EmptyItemFeatureMember
    "send" ( ( name:SysMLName TypePart? )? "of")? ExpressionMember+ "to" ExpressionMember+;
  ControlNode = MergeNode	| DecisionNode | JoinNode | ForkNode;

  //TODO
  /*MergeNode returns SysML::MergeNode :
    	{SysML::MergeNode} isComposite ?= 'merge' ( name = Name TypePart? )? ';'
    ;

    DecisionNode returns SysML::DecisionNode :
    	{SysML::DecisionNode} isComposite ?= 'decide' ( name = Name TypePart? )? ';'
    ;

    JoinNode returns SysML::JoinNode :
    	{SysML::JoinNode} isComposite ?= 'join' ( name = Name TypePart? )? ';'
    ;

    ForkNode returns SysML::ForkNode :
    	{SysML::ForkNode} isComposite ?= 'fork' ( name = Name TypePart? )? ';'
    ;

    EmptyParameter returns SysML::Parameter :
    	{SysML::Parameter}
    ;*/
  MergeNode = isComposite:["merge"]? SysMLNameAndTypePartOptional ";";
  DecisionNode = isComposite:["decide"]? SysMLNameAndTypePartOptional ";";
  JoinNode = isComposite:["join"]? SysMLNameAndTypePartOptional ";";
  ForkNode = isComposite:["fork"]? SysMLNameAndTypePartOptional ";";
  EmptyParameter; //TODO
  SysMLNameAndTypePartOptional = (name:SysMLName TypePart?)?;


  /* ACTION MEMBERSHIPS */
  ActionParameterMember = (direction:FeatureDirection | direction:FeatureDirection? memberName:SysMLName)
    ActionParameter;
  ActionParameterFlowMember = ActionParameterFlow;
  EmptySuccessionMember = EmptySuccession;
  EmptyParameterMember = EmptyParameter;
  /* STATES */
  StateUnit implements Unit = UnitPrefix StateDeclaration StateBody;
  StateDeclaration = ["abstract"]? "state" name:SysMLName TypePart? ActionParameterList? SubsettingPart ValuePart?;
  StateUsage = SysMLName? ActionUsageDeclaration StateBody; //TODO {SysML:StateUsage}
  ExhibitStateUsage = ((((name:SysMLName) TypePart? "as")? Subset+)
    | ( "state" name:SysMLName? TypePart? ))
    ActionParameterList? SubsettingPart ValuePart? StateBody;



  /* TRANSITIONS */
  TransitionStep = "transition" (SysMLNameAndTypePartOptional "first")? TransitionSourceMember+
    TriggerStepMember* GuardExpressionMember* EffectBehaviorMember* "then" TransitionSuccessionMember;
  TargetTransitionStep = TriggerStepMember* GuardExpressionMember* EffectBehaviorMember* "then"
    TransitionSuccessionMember; //TODO make common NT later and write in improvement list
  TriggerStep = EmptyParameterMember ItemFeatureMember;
  EffectBehaviourUsage = EmptyActionUsage | PerformedActionUsage ( "{" ActivityBodyItem* "}" )?;
  TransitionSuccession = EmptySourceEndMember ConnectorEndMember;

  /* TRANSITION MEMBERSHIPS */
  TransitionSourceMember = memberFeature:QualifiedName;
  TransitionSuccessionMember = TransitionSuccession;
  TriggerStepMember = kind:TriggerFeatureKind TriggerStep;
  TriggerFeatureKind = kind:"accept"; //Remark: this is an enum in xtext
  GuardExpressionMember = kind:GuardFeatureKind Expression;
  GuardFeatureKind = guard:"if"; //Remark: this is an enum in xtext
  EffectBehaviorMember = kind: EffectFeatureKind EffectBehaviourUsage;
  EffectFeatureKind = effect:"do"; //Remark: this is an enum in xtext

  /* SUCCESSIONS */
  Succession = SuccessionDeclaration ";";
  SuccessionDeclaration = ( ( name:SysMLName)? TypePart? "first" )?
    ConnectorEndMember+ "then" ConnectorEndMember+;
  TargetSuccession = "then" MultiplicitySourceEndMember ConnectorEndMember+; //TODO MultiplicitySourceEndMember
  EmptySuccession =  "then" MultiplicitySourceEndMember EmptyTargetEndMember; //TODO MultiplicitySourceEndMember
  GuardedSuccession = "succession" (( name:SysMLName)? TypePart? "first")?
    TransitionSourceMember+ GuardExpressionMember+ "then" TransitionSuccessionMember+;
  GuardedTargetSuccession = GuardExpressionMember+  "then" TransitionSuccessionMember+;
  DefaultTargetSuccession = "else" TransitionSuccessionMember+;


  /* ITEM FLOWS */ //Is this AD and IBD?
  ItemFlow = ItemFlowDeclaration DefinitionBody;
  SuccessionItemFlow = ItemFlowDeclaration DefinitionBody;
  ItemFlowDeclaration = ( (name:SysMLName)? TypePart? //TODO I am not sure if "from" or the whole is meant with or
    (( "of" ItemFeatureMember+) | (EmptyItemFeatureMember)) //TODO x0opt EmptyItemFeatureMember
    "from" | EmptyItemFeatureMember )
    ItemFlowEndMember+ "to" ItemFlowEndMember+;
  ItemFeatureTyping = FeatureTyping+ MultiplicityMember*;
  EmptyItemFeature; //TODO {SysML::ItemFeature} x0mty EmptyNT
  ItemFlowEnd = ItemFlowFeatureMember+;
  ItemFlowFeature = Redefinition+;

  /* ITEM FLOW MEMBERSHIPS */
  ItemFeatureMember = (memberName:SysMLName TypedByKeyword)? ItemFeatureTyping;
  ItemFlowEndMember = ItemFlowEnd;
  ItemFlowFeatureMember = ItemFlowFeature;
  EmptyItemFeatureMember = EmptyItemFeature;
}