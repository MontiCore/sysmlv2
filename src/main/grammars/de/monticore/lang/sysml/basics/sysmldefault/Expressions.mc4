/* (c) https://github.com/MontiCore/monticore */
package de.monticore.lang.sysml.basics.sysmldefault;

//TODO should we use JavaClassExpressions?
component grammar Expressions extends de.monticore.expressions.CommonExpressions,
  de.monticore.lang.sysml.basics.SysMLCommonBasis{

  //TODO LiteralsSysML should overwrite or extend Commonliterals, also for JavaClassExpressions
  //TODO the implicitely imported CommonExpressions

  /* EXPRESSIONS */
  //TODO not necessary the AST, but the Grammar can be improved (in Xtext)
  // These Expressions are needed addtionally TODO check if some could be merged with MC Expressions-------->
  SysMLConditionalExpression implements Expression =
      Expression ( // TODO first Expression  could be NullCoalescingExpression  TODO {SysML::OperatorExpression.operand_comp += current}
    		"?" Expression+ ":" Expression+ //TODO second Expression could be  be SysMLConditionalExpression
    	);
  //TODO which are necessary, why this weird circle?
  /* NullCoalescingExpression = ConditionalOrExpression  ( "??" ConditionalOrExpression)*;
  ConditionalOrExpression = ConditionalAndExpression  ( "||" ConditionalAndExpression)*;
  ConditionalAndExpression = OrExpression             ( "&&" OrExpression+ )*;
  OrExpression = XorExpression                        ( "|" XorExpression)*;
  XorExpression = AndExpression                       ( "^" AndExpression)*;
  AndExpression = EqualityExpression                  ( "&" EqualityExpression)*;
  EqualityExpression = ClassificationExpression ((equal:["=="] | notEqual:["!="]) ClassificationExpression)*;
  ClassificationExpression = RelationalExpression (("instanceof"| "hastype") RelationalExpression)*;
  RelationalExpression = AdditiveExpression           (RelationalOperator AdditiveExpression)*;
  RelationalOperator = "<" | ">" | "<=" | ">=";
  AdditiveExpression =  MultiplicativeExpression      ((plus:["+"]|minus:["-"]) MultiplicativeExpression)*;
  MultiplicativeExpression =  UnitsExpression      ((times:["*"]|divide:["/"]|exp:["**"]) UnitsExpression)*;
  UnitsExpression =  UnaryExpression      ("@"  "[" UnaryExpression "]")?;
  UnaryExpression =  SequenceAccessExpression | ("+"|"-"| "!" | "~") SequenceAccessExpression;
  SequenceAccessExpression = PrimaryExpression ("[" Expression+ "]")?;
  PrimaryExpression = BaseExpression? ( "->" SysMLName BodyMember)+; //TODO  BaseExpression? is actually necessary
  BodyExpression = //TODO operator for high priority: =>
    ( BodyParameterMember+ ( BodyParameterMember )* "(" ExpressionMember* ")" ) | ExpressionTyping+;
  ExpressionTyping = type:QualifiedName; //TODO [ SysML::Function | QualifiedName ]*/

  NullCoalescingExpression implements Expression = Expression  ( "??" Expression);
  ConditionalOrExpression implements Expression = Expression  ( "||" Expression);
  ConditionalAndExpression implements Expression = Expression             ( "&&" Expression );
  OrExpression implements Expression = Expression                        ( "|" Expression);
  XorExpression implements Expression = Expression                       ( "^" Expression);
  AndExpression implements Expression = Expression                  ( "&" Expression);
  EqualityExpression implements Expression = Expression ((equal:["=="] | notEqual:["!="]) Expression);
  ClassificationExpression  implements Expression= Expression (("instanceof"| "hastype") Expression);
  RelationalExpression implements Expression = Expression           (RelationalOperator Expression);
  RelationalOperator = "<" | ">" | "<=" | ">=";
  AdditiveExpression implements Expression =  Expression      ((plus:["+"]|minus:["-"]) Expression);
  MultiplicativeExpression implements Expression =  Expression      ((times:["*"]|divide:["/"]|exp:["**"]) Expression);
  UnitsExpression implements Expression =  Expression      ("@"  "[" Expression "]");
  UnaryExpression implements Expression =  ("+"|"-"| "!" | "~") Expression;
  SequenceAccessExpression implements Expression = Expression  ("[" Expression+ "]");
  PrimaryExpression implements Expression = Expression ( "->" SysMLName BodyMember)+; //TODO  BaseExpression? is actually necessary
  BodyExpression = //TODO operator for high priority: =>
    ( BodyParameterMember+ ( BodyParameterMember )* "(" ExpressionMember* ")" ) | ExpressionTyping+;
  ExpressionTyping = type:QualifiedName; //TODO [ SysML::Function | QualifiedName ]


  // Base Expressions TODO check if all are implemented
  BaseExpression implements Expression =
    NullExpression| FeatureReferenceExpression | SequenceConstructionExpression;

  // TODO need to implement this? BaseExpressionLiteralExpression implements Expression =

  FeatureReferenceExpression = FeatureReference+;
  // TODO ... some are missing

  SequenceConstructionExpression = "{" "}" |
    ( "{" Expression ("," SequenceElementList | ".." Expression)? "}" );
  SequenceElementList = Expression ("," SequenceElementList)?;
  NullExpression = "null";
  /* EXPRESSION MEMBERSHIPS */

  ExpressionMemberStd implements ExpressionMember = Expression;
  FeatureReference = memberFeature:QualifiedName;
  TypeReferenceMember = TypeReference;
  NamedExpressionMember = memberName:SysMLName "=>" Expression;
  BodyMember = BodyExpression;
  BodyParameterMember = memberName:SysMLName Parameter;

  /* QUERY PATH EXPRESSIONS */
  SysMLQueryPathExpression implements Expression =
    	QueryHeadExpression
    	( "[" BodyMember+ "]" )?
    	( "/"  QueryNameExpression+	( "[" BodyMember+ "]" )?)*;
  QueryNameExpression = FeatureReference+;
  QueryHeadExpression = "./" FeatureReference+;


  // These Expressions are needed addtionally<-------



  // Base Expressions

  TypeReference = FeatureTyping;



  // TODO Expressions <-------------------------------------------------------------------------

}

