/* (c) https://github.com/MontiCore/monticore */
package de.monticore.lang.sysml.basics.sysmldefault;

//TODO should we use JavaClassExpressions?
component grammar Expressions extends de.monticore.expressions.CommonExpressions,
  de.monticore.lang.sysml.basics.SysMLCommonBasis,
  de.monticore.lang.sysml.basics.sysmldefault.Literals{

  //TODO LiteralsSysML should overwrite or extend Commonliterals, also for JavaClassExpressions
  //TODO the implicitely imported CommonExpressions

  /* EXPRESSIONS */
  //TODO not necessary the AST, but the Grammar can be improved (in Xtext)
  // These Expressions are needed addtionally TODO check if some could be merged with MC Expressions-------->
  SysMLConditionalExpression implements Expression =
      Expression ( // TODO first Expression  could be NullCoalescingExpression  TODO {SysML::OperatorExpression.operand_comp += current}
    		"?" Expression+ ":" Expression+ //TODO second Expression could be  be SysMLConditionalExpression
    	);
  // Following is the Xtext implementation with cycling in the definition
  /* NullCoalescingExpression = ConditionalOrExpression  ( "??" ConditionalOrExpression)*;
  ConditionalOrExpression = ConditionalAndExpression  ( "||" ConditionalAndExpression)*;
  ConditionalAndExpression = OrExpression             ( "&&" OrExpression+ )*;
  OrExpression = XorExpression                        ( "|" XorExpression)*;
  XorExpression = AndExpression                       ( "^" AndExpression)*;
  AndExpression = EqualityExpression                  ( "&" EqualityExpression)*;
  EqualityExpression = ClassificationExpression ((equal:["=="] | notEqual:["!="]) ClassificationExpression)*;
  ClassificationExpression = RelationalExpression (("instanceof"| "hastype") RelationalExpression)*;
  RelationalExpression = AdditiveExpression           (RelationalOperator AdditiveExpression)*;
  RelationalOperator = "<" | ">" | "<=" | ">=";
  AdditiveExpression =  MultiplicativeExpression      ((plus:["+"]|minus:["-"]) MultiplicativeExpression)*;
  MultiplicativeExpression =  UnitsExpression      ((times:["*"]|divide:["/"]|exp:["**"]) UnitsExpression)*;
  UnitsExpression =  UnaryExpression      ("@"  "[" UnaryExpression "]")?;
  UnaryExpression =  SequenceAccessExpression | ("+"|"-"| "!" | "~") SequenceAccessExpression;
  SequenceAccessExpression = PrimaryExpression ("[" Expression+ "]")?;
  PrimaryExpression = BaseExpression? ( "->" SysMLName BodyMember)+;
  BodyExpression =
    ( BodyParameterMember+ ( BodyParameterMember )* "(" ExpressionMember* ")" ) | ExpressionTyping+;
  ExpressionTyping = type:QualifiedName;*/

  NullCoalescingExpression implements Expression = Expression  ( "??" Expression);
  ConditionalOrExpression implements Expression = Expression  ( "||" Expression);
  ConditionalAndExpression implements Expression = Expression             ( "&&" Expression );
  OrExpression implements Expression = Expression                        ( "|" Expression);
  XorExpression implements Expression = Expression                       ( "^" Expression);
  AndExpression implements Expression = Expression                  ( "&" Expression);
  EqualityExpression implements Expression = Expression ((equal:["=="] | notEqual:["!="]) Expression);
  ClassificationExpression  implements Expression= Expression (("instanceof"| "hastype") Expression);
  RelationalExpression implements Expression = Expression           (RelationalOperator Expression);
  RelationalOperator = "<" | ">" | "<=" | ">=";
  AdditiveExpression implements Expression =  Expression      ((plus:["+"]|minus:["-"]) Expression);
  MultiplicativeExpression implements Expression =  Expression      ((times:["*"]|divide:["/"]|exp:["**"]) Expression);
  UnitsExpression implements Expression =  Expression      ("@"  "[" Expression "]");
  UnaryExpression implements Expression =  ("+"|"-"| "!" | "~") Expression;
  SequenceAccessExpression implements Expression = Expression  ("[" Expression+ "]");
  PrimaryExpression implements Expression <300> = Expression ( "->" SysMLName BodyMember)+;
  BodyExpression = //TODO operator for high priority: =>
    ( BodyParameterMember+ ( BodyParameterMember )* "(" ExpressionMember* ")" ) | ExpressionTyping+;
  ExpressionTyping = type:QualifiedName; //TODO [ SysML::Function | QualifiedName ]


  // Base Expressions
  BaseExpression implements Expression =
     NullExpression
    	| LiteralExpression
    	| FeatureReferenceExpression
    	| InvocationExpression
    	| ClassExtentExpression
    	| SequenceConstructionExpression
    	| "(" Expression ")"
    ;

  FeatureReferenceExpression = FeatureReference+;
  InvocationExpression = FeatureTyping "(" Tuple ")"; // TODO tupels seem not to be included in MCLiterals
  Tuple = PositionalTuple | NamedTuple;
  PositionalTuple = ( ExpressionMember || ",")+;
  NamedTuple = ( NamedExpressionMember || ",")+;
  ClassExtentExpression = TypeReferenceMember+ "." "allInstances" "(" ")";
  TypeReference = FeatureTyping;
  //SequenceConstructionExpression = "{" "}" |
  //  ( "{" Expression ("," SequenceElementList | ".." Expression)? "}" );
  //SequenceConstructionExpression = "{" "}" |
  //  ( "{" Expression ("," SequenceElementList |  "." "." {noSpace()}? Expression)? "}" );
  SequenceConstructionExpression = "{" "}" |
    "{" FromToDigitsDotDot Expression "}" |
    //"{" Expression DotDot Expression "}" |
    "{" Expression ("," SequenceElementList)? "}";
  //TODO remove following
  //SequenceConstructionExpression = "{" "}" |
   // ( "{" Expression ("," SequenceElementList | ".." Expression)? "}" )
  //  | ( "{" DigitsDotDot Expression "}") ;
  //fragment token DigitsDotDot = ('0'..'9')+ "..";
  //Size implements Expression = "size" "(x)" "-" Digits;
  // SomeExpression implements Expression ="->forAll n (x[n + 1] == x[n] + v[n] * (5280/3600) * dt)";
  //TODO remove


  SequenceElementList = Expression ("," SequenceElementList)?;
  NullExpression = "null";

  // Literal Expressions

  // => Implemented in Literals

  /* EXPRESSION MEMBERSHIPS */

  ExpressionMemberStd implements ExpressionMember = Expression;
  FeatureReference = memberFeature:QualifiedName;
  TypeReferenceMember = TypeReference;
  NamedExpressionMember = memberName:SysMLName "=>" Expression;
  BodyMember = BodyExpression;
  BodyParameterMember = memberName:SysMLName Parameter;

  /* QUERY PATH EXPRESSIONS */
  SysMLQueryPathExpression implements Expression =
    	QueryHeadExpression
    	( "[" BodyMember+ "]" )?
    	( "/"  QueryNameExpression+	( "[" BodyMember+ "]" )?)*;
  QueryNameExpression = FeatureReference+;
  QueryHeadExpression = "./" FeatureReference+;

}

