/* (c) https://github.com/MontiCore/monticore */
package de.monticore.lang.sysml.basics.sysmldefault;

component grammar Expressions extends de.monticore.expressions.CommonExpressions,
  de.monticore.lang.sysml.basics.SysMLCommonBasis,
  de.monticore.lang.sysml.basics.sysmldefault.Literals{

  /* EXPRESSIONS */
  /*
   * We import CommonExpressions, but we also wanted to make clear how the Expressions of SysML map to the Expressions
   * of CommonExpressions. That is why we comment out the Expressions of SysML and provide the name of the
   * corresponding Expression in CommonExpressions.
   */
  // TODO check if some could be merged with MC Expressions-------->
  SysMLConditionalExpression implements Expression =
      condition:Expression (
    		"?" doOnTrue:Expression+ ":" doOnFalse:Expression+
    	);

  NullCoalescingExpression implements Expression = left:Expression "??" right:Expression;
  // ConditionalOrExpression implements Expression = Expression  ( "||" Expression);
    // covered in CommonExpressions ->  BooleanOrOpExpression
  ConditionalAndExpression implements Expression = left:Expression "&&" right:Expression;
  OrExpression implements Expression = left:Expression "|" right:Expression;
  XorExpression implements Expression = left:Expression "^" right:Expression;
  AndExpression implements Expression = left:Expression "&" right:Expression;
  //EqualityExpression implements Expression = Expression ((equal:["=="] | notEqual:["!="]) Expression);
    // covered in CommonExpressions ->  EqualsExpression, NotEqualsExpression
  ClassificationExpression  implements Expression= Expression ("instanceof"| "hastype") Expression;
  //RelationalExpression implements Expression = Expression           (RelationalOperator Expression);
  //RelationalOperator = "<" | ">" | "<=" | ">=";
    // covered in CommonExpressions -> LessEqualExpression, GreaterEqualExpression, LessThanExpression, GreaterThanExpression
  AdditiveExpression implements Expression =  Expression      ((plus:["+"]|minus:["-"]) Expression);
  MultiplicativeExpression implements Expression =  Expression      ((times:["*"]|divide:["/"]|exp:["**"]) Expression);
  UnitsExpression implements Expression =  Expression      ("@"  "[" Expression "]");
  UnaryExpression implements Expression =  ("+"|"-"| "!" | "~") Expression;
  SequenceAccessExpression implements Expression = Expression  ("[" Expression+ "]");
  PrimaryExpression implements Expression <300> = Expression ( "->" SysMLName BodyMember)+;
  BodyExpression = //TODO operator for high priority: =>
    ( BodyParameterMember+ ( BodyParameterMember )* "(" ExpressionMember* ")" ) | ExpressionTyping+;
  ExpressionTyping = type:QualifiedName; //TODO [ SysML::Function | QualifiedName ]


  // Base Expressions
  BaseExpression implements Expression =
     NullExpression
    	| LiteralExpression
    	| FeatureReferenceExpression
    	| InvocationExpression
    	| ClassExtentExpression
    	| SequenceConstructionExpression
    	| "(" Expression ")"
    ;

  FeatureReferenceExpression = FeatureReference+;
  InvocationExpression = FeatureTyping "(" Tuple ")"; // TODO tupels seem not to be included in MCLiterals
  Tuple = PositionalTuple | NamedTuple;
  PositionalTuple = ( ExpressionMember || ",")+;
  NamedTuple = ( NamedExpressionMember || ",")+;
  ClassExtentExpression = TypeReferenceMember+ "." "allInstances" "(" ")";
  TypeReference = FeatureTyping;
  //SequenceConstructionExpression = "{" "}" |
  //  ( "{" Expression ("," SequenceElementList | ".." Expression)? "}" );
  //SequenceConstructionExpression = "{" "}" |
  //  ( "{" Expression ("," SequenceElementList |  "." "." {noSpace()}? Expression)? "}" );
  SequenceConstructionExpression = "{" "}" |
    "{" FromToDigitsDotDot Expression "}" |
    //"{" Expression DotDot Expression "}" |
    "{" Expression ("," SequenceElementList)? "}";
  //TODO remove following
  //SequenceConstructionExpression = "{" "}" |
   // ( "{" Expression ("," SequenceElementList | ".." Expression)? "}" )
  //  | ( "{" DigitsDotDot Expression "}") ;
  //fragment token DigitsDotDot = ('0'..'9')+ "..";
  //Size implements Expression = "size" "(x)" "-" Digits;
  // SomeExpression implements Expression ="->forAll n (x[n + 1] == x[n] + v[n] * (5280/3600) * dt)";
  //TODO remove


  SequenceElementList = Expression ("," SequenceElementList)?;
  NullExpression = "null";

  // Literal Expressions

  // => Implemented in Literals

  /* EXPRESSION MEMBERSHIPS */

  ExpressionMemberStd implements ExpressionMember = Expression;
  FeatureReference = memberFeature:QualifiedName;
  TypeReferenceMember = TypeReference;
  NamedExpressionMember = memberName:SysMLName "=>" Expression;
  BodyMember = BodyExpression;
  BodyParameterMember = memberName:SysMLName Parameter;

  /* QUERY PATH EXPRESSIONS */
  SysMLQueryPathExpression implements Expression =
    	QueryHeadExpression
    	( "[" BodyMember+ "]" )?
    	( "/"  QueryNameExpression+	( "[" BodyMember+ "]" )?)*;
  QueryNameExpression = FeatureReference+;
  QueryHeadExpression = "./" FeatureReference+;

}

