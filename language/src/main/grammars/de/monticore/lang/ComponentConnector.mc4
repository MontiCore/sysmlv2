package de.monticore.lang;

component grammar ComponentConnector extends
    de.monticore.types.MCBasicTypes,
    de.monticore.symbols.CompSymbols,
    de.monticore.Cardinality {
  /* TODO concrete symbols implementing other interface symbols is problematic and should not happen.
      In our case we require additional symbolrules for transformation that are not present in CompSymbols.
      - Overriding the interface is not possible (0xA4007)
      Potential solution: We define our own component interface symbols with extension to be later migrated to MontiCore
                          - con: no traversal is generated for the ASTs (neither in traverser nor in handler)
   */

  /*
    Pseudo-abstract Component Connector language only for symbols.
   */

  // Scope spanning property is inherited from Component
  symbol MildComponent implements Component = Name;
  symbolrule MildComponent =
    refinementStart: de.monticore.types.check.CompKindExpression?
    isStrongCausal:Boolean
    timing: de.monticore.symbols.compsymbols._symboltable.Timing
    method public MildComponentSymbol resolveRefinementStart() {
      return getEnclosingScope().resolveMildComponent(refinementStart.get().printName()).get();
    }
  ;

  symbol Parameter = Name;
  symbolrule Parameter =
    type: de.monticore.types.check.SymTypeExpression
  ;

  symbol MildPort implements Port = Name;
  symbolrule MildPort =
    cardinality: int

    method public boolean equals(Object other) {
      return other instanceof MildPortSymbol && Objects.equals(getFullName(),
          ((MildPortSymbol) other).getFullName());
    }

    method public int hashCode() {
      return getFullName().hashCode();
    }
  ;

  symbol MildSpecification extends MildComponent = Name assumptions:String* predicates:String*;
}
