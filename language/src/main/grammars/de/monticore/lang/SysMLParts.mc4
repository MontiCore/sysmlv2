/* (c) https://github.com/MontiCore/monticore */
package de.monticore.lang;

component grammar SysMLParts extends SysMLBasis {

  /*
   * ##################################################################
   * Definitions
   * ##################################################################
   */

   symbolrule PartDef =
      directRefinements:de.monticore.types.check.SymTypeExpression*
      requirementType:SysMLReqType;

  // AnonEnumUsage hinzugef√ºgt
  @Override
  symbol scope EnumDef implements SysMLType =
    Modifier UserDefinedKeyword* "enum" "def"
    SysMLIdentifier? Name SysMLCardinality? Specialization*
    ("{"
      (SysMLElement | AnonEnumUsage)*
    "}" | ";") ;

  /**
   * "=10;" is a valid element in the body of an enum def that specializes some other def
   */
  AnonEnumUsage =
    Specialization* DefaultValue
    ("{"
      SysMLElement*
    "}" | ";") ;

  /*
   * ##################################################################
   * Usages
   * ##################################################################
   */

  /**
   * Definitions define a type, usages instantiate it. The SysML is not very clear in this regard and mixes types,
   * definitions, usages, instances, etc. For our purposes (SpesML, MontiBelle), we need typing.
   * The "types" are extracted from the Specializations, specifically the SysMLTypings. Extraction is done during symbol
   * table completion. The SymTypeExpressions only store type expressions, not the actual types or any symbols.
   */
  symbolrule PartUsage =
      types:de.monticore.types.check.SymTypeExpression*
      sysMLIdentifier:Name?
      method public Optional<de.monticore.lang.sysmlparts._symboltable.PartDefSymbol> getPartDef() {
        for (de.monticore.lang.sysmlbasis._ast.ASTSpecialization specialization : this.getAstNode().getSpecializationList()) {
          for (de.monticore.types.mcbasictypes._ast.ASTMCType specializationType : specialization.getSuperTypesList()) {
            var qualified = (de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType) specializationType;
            var name = qualified.getMCQualifiedName().getQName();
            var partDef = (Optional<de.monticore.lang.sysmlparts._symboltable.PartDefSymbol>) this.getEnclosingScope().resolvePartDef(name);
            if(partDef.isPresent()) {
              return partDef;
            }
          }
        }
        return Optional.empty();
      } ;

  symbolrule AttributeUsage =
      types:de.monticore.types.check.SymTypeExpression*
      in:boolean
      out:boolean ;

  astrule AttributeUsage =
      method public Optional<de.monticore.cardinality._ast.ASTCardinality> getCardinality() {
        for (de.monticore.lang.sysmlbasis._ast.ASTSpecialization s: this.getSpecializationList()) {
          if(s instanceof de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) {
            if(((de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) s).isPresentCardinality()) {
              return Optional.of(((de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) s).getCardinality());
            }
          }
        }
        return Optional.empty();
      } ;

  symbolrule PortUsage =
      types:de.monticore.types.check.SymTypeExpression*
      conjugatedTypes:de.monticore.types.check.SymTypeExpression*
      strong:boolean;

  astrule PortUsage =
    method public Optional<de.monticore.cardinality._ast.ASTCardinality> getCardinality() {
      for (de.monticore.lang.sysmlbasis._ast.ASTSpecialization s: this.getSpecializationList()) {
        if(s instanceof de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) {
          if(((de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) s).isPresentCardinality()) {
            return Optional.of(((de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) s).getCardinality());
          }
        }
      }
      return Optional.empty();
    } ;

}
