/* (c) https://github.com/MontiCore/monticore */
package de.monticore.lang;

component grammar SysMLParts extends SysMLBasis {

  /**
   * Causality indication: "instant" = weak causal, "delayed" = strong causal. Defaults to "delayed".
   * TODO Überdenken, wie man das nicht überall erlaubt (Grammar vs. CoCo)
   */
  SysMLCausality implements SysMLElement = "timing" (["instant"] | ["delayed"]) ";" ;

  /*
   * ##################################################################
   * Definitions
   * ##################################################################
   */

  symbol scope (shadowing) PartDef implements SysMLType =
    Modifier "part" "def" Name Specialization*
    ("{"
      SysMLElement*
    "}" | ";") ;

   enum SysMLReqType = "UNKNOWN" | "HLR" | "LLR" | "MIXED" ;

   symbolrule PartDef =
      directRefinements:de.monticore.types.check.SymTypeExpression*
      requirementType:SysMLReqType;

  symbol scope AttributeDef implements SysMLType =
    Modifier "attribute" "def" Name Specialization*
    ("{"
      SysMLElement*
    "}" | ";") ;

  symbol scope EnumDef implements SysMLType =
    Modifier "enum" "def" Name Specialization*
    ("{"
      SysMLEnumConstant*
    "}" | ";") ;

  // TODO Was genau darf in den Body?
  SysMLEnumConstant implements Field = "enum"? Name ("=" Expression)?
    ("{"
      SysMLElement*
    "}" | ";") ;

  symbol scope (shadowing) PortDef implements SysMLType =
    Modifier "port" "def" Name Specialization*
    ("{"
      SysMLElement*
    "}" | ";") ;

  /*
   * ##################################################################
   * Usages
   * ##################################################################
   */

  symbol scope (shadowing) PartUsage implements SysMLElement =
    SysMLFeatureDirection? Modifier "part" SysMLIdentifier? Name
    SysMLCardinality? Specialization* ("=" Expression)? DefaultValue
    ("{"
      SysMLElement*
    "}" | ";") ;

  /**
   * Definitions define a type, usages instantiate it. The SysML is not very clear in this regard and mixes types,
   * definitions, usages, instances, etc. For our purposes (SpesML, MontiBelle), we need typing.
   * The "types" are extracted from the Specializations, specifically the SysMLTypings. Extraction is done during symbol
   * table completion. The SymTypeExpressions only store type expressions, not the actual types or any symbols.
   */
  symbolrule PartUsage =
      types:de.monticore.types.check.SymTypeExpression*
      method public Optional<de.monticore.lang.sysmlparts._symboltable.PartDefSymbol> getPartDef() {
        for (de.monticore.lang.sysmlbasis._ast.ASTSpecialization specialization : this.getAstNode().getSpecializationList()) {
          for (de.monticore.types.mcbasictypes._ast.ASTMCType specializationType : specialization.getSuperTypesList()) {
            var qualified = (de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType) specializationType;
            var name = qualified.getMCQualifiedName().getQName();
            var partDef = (Optional<de.monticore.lang.sysmlparts._symboltable.PartDefSymbol>) this.getEnclosingScope().resolvePartDef(name);
            if(partDef.isPresent()) {
              return partDef;
            }
          }
        }
        return Optional.empty();
      } ;

  // Der Name kann weggelassen werden wenn "attribute" angegeben ist
  // Die Kardinalität kann vor den Spezialisierungen stehen (aber es kann nur eine geben)
  symbol AttributeUsage implements SysMLElement =
      SysMLFeatureDirection? Modifier ("attribute" SysMLIdentifier? Name? | SysMLIdentifier? Name )
      SysMLCardinality? Specialization* ("=" Expression)? DefaultValue
      ("{"
        SysMLElement*
      "}" | ";");

  // Man kann den Namen weglassen wenn es eine Specialisation gibt
  AnonymousAttributeUsage extends AttributeUsage =
      SysMLFeatureDirection? Modifier SysMLIdentifier? Specialization+ ("=" Expression)? DefaultValue
      ("{"
        SysMLElement*
      "}" | ";");

  symbolrule AttributeUsage =
      types:de.monticore.types.check.SymTypeExpression*
      direction:de.monticore.lang.SysMLBasis.SysMLFeatureDirection ;

  astrule AttributeUsage =
      method public Optional<de.monticore.cardinality._ast.ASTCardinality> getCardinality() {
        for (de.monticore.lang.sysmlbasis._ast.ASTSpecialization s: this.getSpecializationList()) {
          if(s instanceof de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) {
            if(((de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) s).isPresentCardinality()) {
              return Optional.of(((de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) s).getCardinality());
            }
          }
        }
        return Optional.empty();
      } ;

  /**
   * PortUsage has a shadowing scope to allow instantiating attributes from its definition. This is done to store
   * additional information resulting from tools processing models. This is a work-in-progress concept as part of
   * @adrian.costin.marin's master thesis.
   * Example:
   * The MontiBelle toolchain will, during its runtime, store generated channel names in modified AttributeUsageSymbols
   * and add these symbols to the PortUsage's scope. Folling invocations of the toolchain are then able to seamlessly
   * integrate with the existing artifacts (i.e., theories containing specific channel names) only by referencing the
   * symboltable (and not needing to re-processes the original models).
   */
  symbol scope (shadowing) PortUsage implements SysMLElement =
      SysMLFeatureDirection? Modifier "port" Name Specialization* DefaultValue";" ;

  symbolrule PortUsage =
      types:de.monticore.types.check.SymTypeExpression*
      conjugatedTypes:de.monticore.types.check.SymTypeExpression*
      strong:boolean;

  astrule PortUsage =
    method public Optional<de.monticore.cardinality._ast.ASTCardinality> getCardinality() {
      for (de.monticore.lang.sysmlbasis._ast.ASTSpecialization s: this.getSpecializationList()) {
        if(s instanceof de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) {
          if(((de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) s).isPresentCardinality()) {
            return Optional.of(((de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) s).getCardinality());
          }
        }
      }
      return Optional.empty();
    } ;

  ConnectionUsage implements SysMLElement =
    ("connection" SysMLIdentifier? Name? Specialization*)?
    "connect" src:MCQualifiedName SysMLCardinality?
    "to" tgt:MCQualifiedName SysMLCardinality?
    ("{"
       SysMLElement*
     "}" | ";") ;

  /*
   * ##################################################################
   * Items
   * ##################################################################
   */

  symbol scope ItemDef implements SysMLType =
    Modifier "item" "def" Name Specialization* ("(" (SysMLParameter || ",")* ")")?
    ("{"
      SysMLElement*
    "}" | ";") ;

  symbol scope ItemUsage implements SysMLElement =
    SysMLFeatureDirection? Modifier "item" (Name Specialization*)? ("(" (SysMLParameter || ",")* ")")? DefaultValue
    ("{"
      SysMLElement*
     "}" | ";")? ;

  /*
   * ##################################################################
   * Occurences
   * ##################################################################
   */

  symbol scope (shadowing) OccurenceUsage implements SysMLElement =
    Modifier ["event"]? "occurrence" SysMLIdentifier? Name SysMLCardinality? Specialization*
    ("{"
      SysMLElement*
    "}" | ";") ;

  /**
   * An event occurrence usage may also be declared using just the keyword event instead of event occurrence. In
   * this case, the declaration does not include either a name or a short name. Instead, the referenced event occurrence of
   * the event occurrence usage is identified by giving a qualified name or feature chain immediately after the event
   * keyword.
   */
  EventOccurrenceUsage implements SysMLElement =
    Modifier "event" MCQualifiedName SysMLCardinality?
    ("{"
      SysMLElement*
    "}" | ";") ;

}
