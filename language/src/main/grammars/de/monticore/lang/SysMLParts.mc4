/* (c) https://github.com/MontiCore/monticore */
package de.monticore.lang;

component grammar SysMLParts extends SysMLBasis {

  /**
   * Causality indication: "instant" = weak causal, "delayed" = strong causal. Defaults to "delayed".
   * TODO Überdenken, wie man das nicht überall erlaubt (Grammar vs. CoCo)
   */
  SysMLCausality implements SysMLElement = "timing" (["instant"] | ["delayed"]) ";" ;

  /*
   * ##################################################################
   * Definitions
   * ##################################################################
   */

  symbol scope (shadowing) PartDef implements SysMLType =
    Modifier "part" "def" Name Specialization*
    ("{"
      SysMLElement*
    "}" | ";") ;

   enum SysMLReqType = "UNKNOWN" | "HLR" | "LLR" | "MIXED" ;

   symbolrule PartDef =
      directRefinements:de.monticore.types.check.SymTypeExpression*
      requirementType:SysMLReqType;

  symbol scope AttributeDef implements SysMLType =
    "attribute" "def" Name Specialization*
    ("{"
      SysMLElement*
    "}" | ";") ;

  symbol scope EnumDef implements SysMLType =
    "enum" "def" Name Specialization*
    ("{"
      SysMLEnumConstant*
    "}" | ";") ;

  SysMLEnumConstant implements Field = "enum"? Name ";" ;

  symbol scope (shadowing) PortDef implements SysMLType =
    Modifier "port" "def" Name Specialization*
    ("{"
      SysMLElement*
    "}" | ";") ;

  /*
   * ##################################################################
   * Usages
   * ##################################################################
   */

  symbol scope (shadowing) PartUsage implements SysMLElement =
    Modifier SysMLFeatureDirection? "part" Name Specialization*
    ("{"
      SysMLElement*
    "}" | ";") ;

  /**
   * Definitions define a type, usages instantiate it. The SysML is not very clear in this regard and mixes types,
   * definitions, usages, instances, etc. For our purposes (SpesML, MontiBelle), we need typing.
   * The "types" are extracted from the Specializations, specifically the SysMLTypings. Extraction is done during symbol
   * table completion. The SymTypeExpressions only store type expressions, not the actual types or any symbols.
   */
  symbolrule PartUsage =
      types:de.monticore.types.check.SymTypeExpression*
      method public Optional<de.monticore.lang.sysmlparts._symboltable.PartDefSymbol> getPartDef() {
        for (de.monticore.lang.sysmlbasis._ast.ASTSpecialization specialization : this.getAstNode().getSpecializationList()) {
          for (de.monticore.types.mcbasictypes._ast.ASTMCType specializationType : specialization.getSuperTypesList()) {
            var qualified = (de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType) specializationType;
            var name = qualified.getMCQualifiedName().getQName();
            var partDef = (Optional<de.monticore.lang.sysmlparts._symboltable.PartDefSymbol>) this.getEnclosingScope().resolvePartDef(name);
            if(partDef.isPresent()) {
              return partDef;
            }
          }
        }
        return Optional.empty();
      } ;

  symbol AttributeUsage implements SysMLElement =
      SysMLFeatureDirection? "attribute" Name Specialization* ("=" Expression)? ";"  ;

  symbolrule AttributeUsage =
      types:de.monticore.types.check.SymTypeExpression*
      direction:de.monticore.lang.SysMLBasis.SysMLFeatureDirection ;

  astrule AttributeUsage =
      method public Optional<de.monticore.cardinality._ast.ASTCardinality> getCardinality() {
        for (de.monticore.lang.sysmlbasis._ast.ASTSpecialization s: this.getSpecializationList()) {
          if(s instanceof de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) {
            if(((de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) s).isPresentCardinality()) {
              return Optional.of(((de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) s).getCardinality());
            }
          }
        }
        return Optional.empty();
      } ;

  /**
   * PortUsage has a shadowing scope to allow instantiating attributes from its definition. This is done to store
   * additional information resulting from tools processing models. This is a work-in-progress concept as part of
   * @adrian.costin.marin's master thesis.
   * Example:
   * The MontiBelle toolchain will, during its runtime, store generated channel names in modified AttributeUsageSymbols
   * and add these symbols to the PortUsage's scope. Folling invocations of the toolchain are then able to seamlessly
   * integrate with the existing artifacts (i.e., theories containing specific channel names) only by referencing the
   * symboltable (and not needing to re-processes the original models).
   */
  symbol scope (shadowing) PortUsage implements SysMLElement =
      Modifier SysMLFeatureDirection? "port" Name Specialization* DefaultValue";" ;

  symbolrule PortUsage =
      types:de.monticore.types.check.SymTypeExpression*
      conjugatedTypes:de.monticore.types.check.SymTypeExpression*
      strong:boolean;

  astrule PortUsage =
    method public Optional<de.monticore.cardinality._ast.ASTCardinality> getCardinality() {
      for (de.monticore.lang.sysmlbasis._ast.ASTSpecialization s: this.getSpecializationList()) {
        if(s instanceof de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) {
          if(((de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) s).isPresentCardinality()) {
            return Optional.of(((de.monticore.lang.sysmlbasis._ast.ASTSysMLTyping) s).getCardinality());
          }
        }
      }
      return Optional.empty();
    } ;

  ConnectionUsage implements SysMLElement =
      "connect" src:MCQualifiedName "to" tgt:MCQualifiedName ";";

}
