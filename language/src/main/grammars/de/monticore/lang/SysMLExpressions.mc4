/* (c) https://github.com/MontiCore/monticore */
package de.monticore.lang;

component grammar SysMLExpressions extends de.monticore.literals.MCCommonLiterals,          // SignedLiteral
                                           de.monticore.expressions.CommonExpressions,
                                           de.monticore.expressions.AssignmentExpressions,
                                           de.monticore.expressions.StreamExpressions,
                                           de.monticore.ocl.OCLExpressions,
                                           de.monticore.ocl.SetExpressions,
                                           de.monticore.types.MCBasicTypes,                 // MCType
                                           SysMLBasis
{
  /**
   * Extends the usual FieldAccessExpression by introducing a SysML specific
   * notation of writing qualified names.
   * This is syntactically similar to package names:
   * So when the language shall also allow QualifiedNames as Expressions,
   * they might be parsed here. E.g. in "x::y::Person", "x" is
   * parsed as NameExpression, even though it is a package name.
   * This is to be resolved via SymbolTable.
   * When resolved, the AST should be restructured directly after the parsing.
   */
  SysMLFieldAccessExpression extends FieldAccessExpression implements Expression <290> =
    Expression "::" Name;

  SysMLInstantiation implements Expression = key("new") {noSpace(2)}? MCType Arguments;

  /**
   * Infinity literal can be negative, but...
   * - the second token (after "-") must be "INF" and
   * - there cannot be any space between "-" and "INF"
   */
  Infinity implements Literal, SignedLiteral =
    {cmpToken(2,"INF") && noSpace(2)}? (negative:["-"]) "INF" | "INF" ;

  // Add "nat" to primitives
  MCPrimitiveTypeWithNat extends MCPrimitiveType implements MCType =
     primitive: [ "boolean" | key("byte") | "short" | "int"
                  | "long" | "char" |"float" | "double" | key("nat") ];

  /**
   * This part is a little experiment. Instead of wasting ASCII-characters for mathematical symbols, we use the latex
   * commands and render them nicely using VSCode's "Prettify Symbols Model" extension.
   * The priority is copied from the LessEqual-, GreaterEqual-, etc. -Expressions (CommonExpressions).
   */
  SubsetEquationExpression implements Expression <150>, InfixExpression =
    left:Expression operator:"\\subseteq" right:Expression ;

  SubsetExpression implements Expression <150>, InfixExpression =
    left:Expression operator:"\\subset" right:Expression ;

  SupersetEquationExpression implements Expression <150>, InfixExpression =
    left:Expression operator:"\\supseteq" right:Expression ;

  SupersetExpression implements Expression <150>, InfixExpression =
    left:Expression operator:"\\supset" right:Expression ;

  ElementOfExpression implements Expression <150>, InfixExpression =
    left:Expression operator:"\\in" right:Expression ;

  /**
   * Um einem mit einer "variablen" Kardinalität (zB. [1..*]) gekennzeichneten Ding etwas zuzuweisen, benutzt SysML den
   * Ausdruck "variablesDing = (1, 2, 3)". Man kann auch bei optionalen nix zuweisen: "optional = ( )".
   * Prio von 330 ist ein bisschen höher als BracketExpression.
   * Wird statt BracketExpression geparst.
   */
  SysMLBracketExpression extends BracketExpression implements Expression <330> = "(" (Expression || ",")* ")" ;

  // Unsicher ob das irgendwo clasht
  SysMLPower implements Expression = Expression "^" Expression ;

  /* Aus MCJavaLiterals.mc4#L173 kopiert */
  ScientificENotatationLiteral implements NumericLiteral <100> =
     source:DecimalFloatingPointLiteral ;

  /* Hier wurde im Vergleich zu MCJavaLiterals.mc4 leicht modifiziert um Clash mit DoubleLiteral zu vermeiden */
  token DecimalFloatingPointLiteral
     =   Digits '.' Digits? ExponentPart
       |        '.' Digits  ExponentPart
       | Digits             ExponentPart;

  fragment token ExponentPart
    = ExponentIndicator SignedInteger;

  fragment token ExponentIndicator
    = 'e' | 'E';

  fragment token SignedInteger
    = Sign? Digits;

  fragment token Sign
    = '+' | '-';

}
